# -*- coding: utf-8 -*-
"""Rain Removal

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LtTXFeDdFwfJLBhWsSW6v9uadf-eve7l
"""

'''
Importing all necessary libraries
'''
import cv2
import numpy as np
from google.colab.patches import cv2_imshow

'''
Reading Image
'''
colored = cv2.imread("worthy.jpg")
cv2_imshow(colored)

'''
Background Detection
'''
def transperency_output(image):  
    gray = cv2.imread(image,cv2.IMREAD_GRAYSCALE)
    transparent = cv2.imread(image, cv2.IMREAD_UNCHANGED)  

    mask = np.zeros((gray.shape[0],gray.shape[1]), dtype=bool)
    mask[transparent[:,:,2]<np.mean(transparent[:,:,2])] = True
    mask[transparent[:,:,0]>np.mean(transparent[:,:,0])] = True
    
    gray[mask]=0
    gray[mask!=True]=255
    
    print("Foregound/Transperency output is - ")
    cv2_imshow(gray)

transperency_output("worthy.jpg")

'''
Rain pixels augmentation value functions
'''

def average_pixels(image,i,j,matrix_size):
    '''
    Returns the average value of the rain droplets' neighboring pixels. 
    A matrix of neighbouring pixels of shape Size x Size is created. 
    '''
    matrix = -np.ones((matrix_size,matrix_size))
    for x in range(-(matrix_size-1)//2,(matrix_size+1)//2):
        for y in range(-(matrix_size-1)//2,(matrix_size+1)//2):
            if (i+x<0) or (j+y<0):
                continue
            if (i+x>(image.shape[0]-1)) or (j+y>(image.shape[1]-1)):
                continue
            if (x==0) and (y==0):
                continue
            matrix[x+(matrix_size-1)//2, y+(matrix_size-1)//2] = image[i+x,j+y]

    return np.sum(matrix[matrix!=-1])/np.sum(matrix!=-1)


def avg_row_pixels(image,i,j,row_size):
    '''
    Returns the average value of the row neighbours. The number of neighbours 
    to be considered is specified by row_size. 
    '''
    matrix = -np.ones(row_size)
    for x in range(-(row_size-1)//2,(row_size+1)//2):
            if (i+x<0):
                continue
            if (i+x>(image.shape[0]-1)):
                continue
            if (x==0):
                continue
            matrix[x+(row_size-1)//2] = image[i+x,j]

    return np.mean(matrix[matrix!=-1])


def min_row_pixels(image,i,j,row_size):
    '''
    Returns the minimum value amongst row neighbours. The number of neighbours 
    to be considered is specified by row_size.
    '''
    matrix = -np.ones(row_size)
    for x in range(-(row_size-1)//2,(row_size+1)//2):
            if (i+x<0):
                continue
            if (i+x>(image.shape[0]-1)):
                continue
            if (x==0):
                continue
            matrix[x+(row_size-1)//2] = image[i+x,j]

    return min(matrix[matrix!=-1])

'''
De-raining using Luminance Rain detection
'''

def de_rain_luminance(image, function = average_pixels):
    '''
    This function takes the image and produces the de-rained output 
    by using luminance detection, specified rain removal function
    and background mask generation using Transparency channel
    '''
    colored = cv2.imread(image)
    gray = cv2.imread(image,cv2.IMREAD_GRAYSCALE)
    transparent = cv2.imread(image, cv2.IMREAD_UNCHANGED)

    mask = np.zeros((transparent.shape[0],transparent.shape[1]), dtype=bool)
    mask[transparent[:,:,2]<np.mean(transparent[:,:,2])] = True
    mask[transparent[:,:,0]>np.mean(transparent[:,:,0])] = True

    red = colored[:,:,0].copy()
    green = colored[:,:,1].copy()
    blue = colored[:,:,2].copy()
    
    lumA = (0.2126*red) + (0.7152*green) + (0.0722*blue)

    for size in range(5,6,2):
        red = colored[:,:,0].copy()
        green = colored[:,:,1].copy()
        blue = colored[:,:,2].copy()
        for k in range(0,colored.shape[0],80):
            for j in range(0,colored.shape[1],30):
                rain_index = np.argwhere(gray[k:k+80,j:j+30]> (np.mean(lumA[k:k+80,j:j+30], axis=1).reshape(-1,1)))
                for [x,y] in rain_index:
                    if mask[x+k,y+j]==True:                                         #x,y -> rain index
                        red[x+k,y+j] = function(red,x+k,y+j,size)
                        green[x+k,y+j] = function(green,x+k,y+j,size)
                        blue[x+k,y+j] = function(blue,x+k,y+j,size)
    
        colored_new = np.dstack((red,green,blue))
        print("De-rained Image using Luminance Rain Detection- ")
        cv2_imshow(colored_new) 



'''
De-raining using Row-Mean detection
'''

def de_rain_row_mean(image, function = average_pixels):
    '''
    This function takes the image and produces the de-rained output 
    by using Row-Mean detection, specified rain removal function
    and background mask generation using Transparency channel
    '''
    colored = cv2.imread(image)
    gray = cv2.imread(image,cv2.IMREAD_GRAYSCALE)
    transparent = cv2.imread(image, cv2.IMREAD_UNCHANGED)

    mask = np.zeros((transparent.shape[0],transparent.shape[1]), dtype=bool)
    mask[transparent[:,:,2]<np.mean(transparent[:,:,2])] = True
    mask[transparent[:,:,0]>np.mean(transparent[:,:,0])] = True


    for size in range(5,6,2):
        red = colored[:,:,0].copy()
        green = colored[:,:,1].copy()
        blue = colored[:,:,2].copy()
        for k in range(0,colored.shape[0],80):
            for j in range(0,colored.shape[1],30):
                rain_index = np.argwhere(gray[k:k+80,j:j+30]> (np.mean(gray[k:k+80,j:j+30], axis=1).reshape(-1,1)))
                for [x,y] in rain_index:
                    if mask[x+k,y+j]==True:                                         #x,y -> rain index
                        red[x+k,y+j] = function(red,x+k,y+j,size)
                        green[x+k,y+j] = function(green,x+k,y+j,size)
                        blue[x+k,y+j] = function(blue,x+k,y+j,size)

        colored_new = np.dstack((red,green,blue))
        print("De-rained Image using Row-Mean Rain Detection- ")
        cv2_imshow(colored_new) 



'''
De-raining using Canny Edge detection
'''

def de_rain_canny(image,function):
    '''
    This function takes the image and produces the de-rained output 
    by using Row-Mean detection, specified rain removal function
    and background mask generation using Transparency channel
    '''
    colored = cv2.imread(image)
    gray = cv2.imread(image,cv2.IMREAD_GRAYSCALE)
    transparent = cv2.imread(image, cv2.IMREAD_UNCHANGED)
    
    mask = np.zeros((transparent.shape[0],transparent.shape[1]), dtype=bool)
    mask[transparent[:,:,2]<np.mean(transparent[:,:,2])] = True
    mask[transparent[:,:,0]>np.mean(transparent[:,:,0])] = True
    
    edges = cv2.Canny(gray,9,15)
    #Fill the edges to get rain streaks index
    for row_index in range(len(edges)):
        rain_edges = np.argwhere(edges[row_index]==255).flatten()
        for i in range(len(rain_edges)-1):
            if (rain_edges[i+1]-rain_edges[i]<=4):
                for index in range(rain_edges[i]+1,rain_edges[i+1]):
                    edges[row_index,index]=255
                    
    
    for size in range(5,6,2):
        red = colored[:,:,0].copy()
        green = colored[:,:,1].copy()
        blue = colored[:,:,2].copy()
        for k in range(0,colored.shape[0],80):
            for j in range(0,colored.shape[1],30):
                rain_index = np.argwhere(edges[k:k+80,j:j+30]==255)
                for [x,y] in rain_index:
                    if mask[x+k,y+j]==True:                                         #x,y -> rain index
                        red[x+k,y+j] = average_pixels(red,x+k,y+j,size)
                        green[x+k,y+j] = average_pixels(green,x+k,y+j,size)
                        blue[x+k,y+j] = average_pixels(blue,x+k,y+j,size)
    
        colored_new = np.dstack((red,green,blue))
        print("De-rained Image using Canny Edge Detection - ")
        cv2_imshow(colored_new)

def de_rain(image_name = 'worthy.jpg',detection = 'Row-Mean Rain Detection', function = "average pooling"):
    global time_matrix
    start = time.time()
    print("Execution Started for De-raining using "+detection)
    
    if (function == "average pooling"):
        function = average_pixels
    elif (function == "row average"):
        function = avg_row_pixels
    elif (function == 'row min'):
        function = min_row_pixels
    else:
        print("Wrong function input. Try again")
        exit()
        
    if detection == 'Row-Mean Rain Detection':
        de_rain_row_mean(image_name, function)
    elif detection == 'Luminance Rain Detection':
        de_rain_luminance(image_name, function)
    elif detection == "Canny Edge Detection":
        de_rain_canny(image_name, function)
        
    end = time.time()
    time_matrix.append("Total time taken for execution using "+detection+" = "+str(end-start))

time_matrix = []

print("Original Image - ")
cv2_imshow(colored)

de_rain()
de_rain(detection="Luminance Rain Detection")
de_rain(detection="Canny Edge Detection")

print("\n\n\n")
print(*time_matrix, sep="\n")

